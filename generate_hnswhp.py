#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
gen_hnswhp.py â€” generator for pgvector/src/hnswhp.c

This script materializes a fixed set of random hyperplanes for SimHash
(random hyperplane LSH) and emits a C source file that ONLY embeds the
hyperplane matrix as a compile-time constant.

What it generates:
  - A single C translation unit containing:
        static const float HNSW_R[<bits>][<dim>] = { ... };

Design notes:
  - Distribution is fixed to standard Gaussian N(0,1) per row, followed by
    L2 normalization for numerical stability. Only the sign of dot products
    matters for SimHash, so normalization is optional but harmless.

Usage:
  python gen_hnswhp.py \
      --bits 64 \
      --dim 2000 \
      --seed 42 \
      --out pgvector/src/hnswhp.c
"""

import argparse
import datetime
import platform
import numpy as np


def gen_hyperplanes(bits: int, dim: int, seed: int) -> np.ndarray:
    """
    Generate k (=bits) random hyperplanes in R^dim.
    """
    rng = np.random.default_rng(seed)
    R = rng.normal(loc=0.0, scale=1.0, size=(bits, dim)).astype(np.float32)
    # Only the direction matters for SimHash (sign of dot), but L2-normalize for numerical stability
    norms = np.linalg.norm(R, axis=1, keepdims=True)
    norms[norms == 0] = 1.0
    R = (R / norms).astype(np.float32)
    return R


def c_float_literal(x: float) -> str:
    # Emit a C float literal with a trailing 'f' and sufficient precision.
    return f"{x:.8f}f"


def emit_c_file(out_path: str, R: np.ndarray, bits: int, dim: int, seed: int):
    ts = datetime.datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")
    py_ver = platform.python_version()
    np_ver = np.__version__

    with open(out_path, "w", encoding="utf-8") as f:
        f.write("/*\n")
        f.write(" * hnswhp.c - Auto-generated SimHash hyperplanes for pgvector (HNSW)\n")
        f.write(" *\n")
        f.write(f" * Generated: {ts}\n")
        f.write(f" * Arguments: bits = {bits}, dim = {dim}, seed = {seed}\n")
        f.write(f" * Python: {py_ver}\n")
        f.write(f" * NumPy : {np_ver}\n")
        f.write(" *\n")
        f.write(" * This file is generated by gen_hnswhp.py. Do not edit manually.\n")
        f.write(" */\n")

        f.write("#include \"hnsw.h\"\n\n")

        # Matrix constant: [bits][dim]
        f.write("/* Random hyperplanes: shape [HNSW_NEIGHBOR_SIMHASH_BITS][HNSW_MAX_DIM] */\n")
        f.write("const float hnsw_neighbor_simhash_r[HNSW_NEIGHBOR_SIMHASH_BITS][HNSW_MAX_DIM] = {\n")
        for i in range(bits):
            row = ", ".join(c_float_literal(v) for v in R[i])
            f.write(f"\t{{ {row} }},\n")
        f.write("};\n\n")

    print(f"[gen_hnswhp.py] wrote: {out_path} (bits={bits}, dim={dim})")


def main():
    ap = argparse.ArgumentParser(description="Generate pgvector/src/hnswhp.c with fixed SimHash hyperplanes.")
    ap.add_argument("--bits", type=int, default=64, help="number of SimHash bits (e.g., 64, 128)")
    ap.add_argument("--dim", type=int, required=True, help="vector dimension (must match index dimension)")
    ap.add_argument("--seed", type=int, default=42, help="RNG seed")
    ap.add_argument("--out", type=str, required=True, help="output C file path (e.g., pgvector/src/hnswhp.c)")
    args = ap.parse_args()

    if args.bits <= 0 or args.dim <= 0:
        print("bits and dim must be positive", file=sys.stderr)
        sys.exit(1)

    R = gen_hyperplanes(args.bits, args.dim, args.seed)
    emit_c_file(args.out, R, args.bits, args.dim, args.seed)


if __name__ == "__main__":
    main()

